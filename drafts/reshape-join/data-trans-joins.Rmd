---
title: "Reshaping and Joining Data in R"
description: |
  "*separate, unite, and join data*"
date: "`r Sys.Date()`"
output:
  distill::distill_article:
    toc: true
    toc_float: yes
    toc_depth: 3
    
always_allow_html: true
---

```{r , include=FALSE}
library(tidyverse)
library(skimr)
library(fivethirtyeight)
library(fivethirtyeightdata)
# create data folder
knitr::opts_chunk$set(
  cache = FALSE,
  echo = TRUE,
  collapse = FALSE,
  eval = TRUE,
  message = FALSE,
  warning = FALSE,
  dev = "ragg_png",
  out.width = '85%',
  fig.path = "img/",
  dpi = 320,
  fig.align = "center",
  fig.width = 8.5,
  fig.height = 6,
  fig.retina = 2
  )
fs::dir_create("data")
knitr::opts_knit$set(root.dir = '/Users/mjfrigaard/Dropbox/@projects/high-priority/@data-journalism/course-website/FA22-JOUR301/drafts/reshape-join/')
```

# Objectives 

This document outlines some common data reshaping/joining tasks with the  `tidyr` and `dplyr` packages. **If you've ever Googled 'how to perform [x] in R', you've probably discovered there are multiple ways to accomplish [x].** The methods I present here are not exhaustive, and I've tried to balance the trade-off between 1) solutions/functions that solve problems with the fewest number of keystrokes, and 2) code that's possible for you (or your collaborators) to be able to read.

## Load packages 

`tidyr` is part of the core `tidyverse` packages, so we install and load this meta-package below. 

```{r packages, eval=FALSE}
install.packages("tidyverse")
library(tidyverse)
library(fivethirtyeight)
```


## Tidy data

There are two principles for tidy data: 

1. Columns hold *variables*    
2. Rows hold *observations*    
3. Cells (the intersection of rows and columns) hold *values*  

We're going to be using small samples of three datasets from the [`fivethirtyeight` package](https://fivethirtyeight-r.netlify.app/), and the `BloodPressures` dataset. 


### `EndorseSample`

There are multiple ways data can be 'less-than tidy.' We'll start with a common example, which is two variables (and their values) stored in a single column.  

Below is a subset of the `endorsements_2020` dataset named `EndorseSample`. Read more about the `endorsements_2020` dataset by typing `??endorsements_2020` into the console. 

```{r EndorseSample, message=FALSE, warning=FALSE}
EndorseSample <- readr::read_csv("https://bit.ly/3S7gYuh")
glimpse(EndorseSample)
```

Notice the `location` variable has two values (`state` and `city`) stored in the same column. 

### `FandangoSample`

In another example of un-tidy data, we'll look at the dataset below which comes from the `fandango` dataset. 

```{r FandangoSample, message=FALSE, warning=FALSE}
FandangoSample <- readr::read_csv(file = "https://bit.ly/3Tg1zt6")
glimpse(FandangoSample)
```

This dataset has two *similar* scores combined into a single column `rottentomatoes_scores`

+ `rottentomatoes_user`: The Rotten Tomatoes user score for the film (expressed as a percent)

+ `rt_user_norm`: The Rotten Tomatoes user score for the film , normalized to a 0 to 5 point system (expressed as 'score `out of 5`')

### `DailyShowSample`

Below is a sample from the `daily_show_guests` dataset. The guests names are separated into `first_name` and `last_name` columns. 

```{r DailyShowSample, message=FALSE, warning=FALSE}
DailyShowSample <- readr::read_csv("https://bit.ly/3yR2PuA")
glimpse(DailyShowSample)
```

### `BloodPressures`

The `BloodPressures` dataset has names, blood pressures, and units for five people. These data contain 1) multiple measurements in one column, and 2) multiple units in one column.  

```{r create-BloodPressures, echo=FALSE, eval=TRUE}
BloodPressures <- tibble::tribble(
                 ~name, ~blood_pressure,                                 ~units,
      "Maximo Garrett",        "119/75", "systolic (mm Hg) / diastolic (mm Hg)",
     "Conner Jacobson",        "121/82", "systolic (mm Hg) / diastolic (mm Hg)",
      "Kirsten Adkins",        "115/72", "systolic (mm Hg) / diastolic (mm Hg)",
     "Carolyn Dickson",        "130/85", "systolic (mm Hg) / diastolic (mm Hg)",
        "Frank Farley",        "125/81", "systolic (mm Hg) / diastolic (mm Hg)"
     )
```

```{r BloodPressures}
glimpse(BloodPressures)
```

***

# Reshaping Columns and Rows 

In the next few exercises, we'll go over how (and *when*) to use `separate()`, `separate_rows()`, and `unite()`. These functions are typically used in a data wrangling 'pipeline', so many of these examples have been reduced to focus on on the function arguments. 

## `separate()` 

This allows us to split columns apart into multiple variables. 

Take another look at `EndorseSample` below:

```{r glimpse-EndorseSample, eval=TRUE}
glimpse(EndorseSample)
```

### Arguments

The arguments for `separate_rows()` are below:

```{r separate_args, eval=FALSE}
separate(data = , col = , into = , sep = , remove = TRUE, 
         convert = FALSE, extra = "warn", fill = "warn", ... = )
```

+ The `data` is whatever table we're looking to wrangle  

+ `col` are the columns that need separating, and `into` should contain the names of the new columns we want to create with the separated values  

+ The `sep` argument is the *separator between columns.*, and it defaults to `"[^[:alnum:].]+"` (which will match on just about any number or punctuation)  

+ `remove` controls what to do with the column after we've separated the values (defaults to `TRUE`, but I initially like to set to `FALSE` to review)  

+ `extra` controls what will happen with extra pieces (defaults to `"warn"`, but other options are `"drop"` or `"merge"`). See `??separate()` for more info. 

+ `fill` is similar to `extra`, but controls what will happen when there aren't enough values in the column we're separating. Defaults to `"warn"`, but other options are `"right"` or `"left"`). See `??separate()` for more info. 

The code below separates `location` into `state` and `city`.

```{r separate-sol}
EndorseSample %>% 
    separate(col = location, 
             into = c("state", "city"), 
             sep = ", ", 
             remove = FALSE) %>% 
    select(location, state, city)
```

The `sep` argument is the character we want to separate the values on (in our case, it's a comma with a space: `", "`), and we add the `remove = FALSE` so the `location` variable stays in the dataset. 

We can also see by adding `select()` with 1) the original column, and 2) the two columns we created to the end of the pipeline, we're able to view the result before assigning it to an output. 

***

## `separate_rows()` 

`separate_rows()` is similar to `separate()`, but drops the values down the rows. This is commonly used when we have more than one *similar* value in each column, or a ratio/fraction.

### Arguments 

The arguments for `separate_rows()` are below: 

```{r separate_rows_args, eval=FALSE}
separate_rows(data = , ... = , sep = , convert = FALSE)
```

+ The `data` is whatever table we're looking to wrangle 

+ The `...` is a placeholder for the columns we want to separate across the rows 

+ The `sep` argument is similar to `separate()` (*separator delimiting collapsed values*), and it defaults to the same regular expression `"[^[:alnum:].]+"`  

+ `convert` controls whether to convert the columns to a specific type (i.e., `numeric`, `integer`, etc.). Defaults to `FALSE`. 

Take a look at `BloodPressures` below: 

```{r head-BloodPressures}
head(BloodPressures)
```

The code below separates the `blood_pressure` into two values, but places the second value on the following row:  

```{r separate_rows_ex_01}
BloodPressures |> 
  separate_rows(blood_pressure) |> 
  select(blood_pressure, units)
```

### The `sep` argument

Notice that we omitted the `sep` argument and it still separated the values on the correct character? That's because the default `sep` pattern (`"[^[:alnum:].]+"`) will match the correct character (`"/"`). 

### Multiple columns

One issue with the output above is that the `units` are still in the previous format (`systolic (mm Hg) / diastolic (mm Hg)`). Fortunately, we can just add a second variable to the first argument in `separate_rows()` (as a vector in `c()`). 

```{r separate_rows_ex_02, error=TRUE}
BloodPressures |> 
  separate_rows(
    c(blood_pressure, units)) 
```

We get an error because we have to provide the `sep` argument (and it's a good habit to include it, just to be more explicit).

```{r separate_rows_ex_03}
BloodPressures |> 
  separate_rows(
    c(blood_pressure, units), 
    # include sep here
    sep = "/") |> 
  select(blood_pressure, units)
```

Now we have both `blood_pressure` and `units` in their own columns. We would probably want to `rename` these variables something more precise (with names that will make it easier to locate variables in future pipelines (i.e., using `starts_with("bp")`). 

```{r separate_rows_ex_04}
BloodPressures |>
  separate_rows(c(blood_pressure, units), sep = "/") |>
  dplyr::rename(
    bp = blood_pressure,
    bp_units = units) |> 
  select(starts_with("bp"))
```


## Separate more complicated rows

Let's take another look at `FandangoSample` below. 

```{r glimpse-FandangoSample}
glimpse(FandangoSample)
```

### Shorten column names 

The first thing we want to do is reduce the length of the `rottentomatoes_scores` column name. This is a lot to type, and it technically contains two *versions* of scores (the `%` and `score`/`out of 5`). We'll rename this column `all_rt_vals`. 

```{r all_rt_vals}
FandangoSample <- FandangoSample %>% 
  rename(all_rt_vals = rottentomatoes_scores)
head(FandangoSample)
```

### The `sep` argument

If we use `separate_rows()` and leave `sep` empty, it will work because the default value will match the `"/"` character.  `convert` set to `TRUE`, we see the following: 

```{r separate_rows-ex, eval=TRUE}
FandangoSample %>% 
  separate_rows(all_rt_vals, convert = TRUE)
```

This puts the percentages and scores on separate rows (like the function's name!), but this requires some additional attention: 

1. First, we need to include an index for the type of score, `rt_key`, that tells us whether the score in `all_rt_vals` is a `Raw user score (%)` or a `Normalized user score (out of 5)`.  

    ```{r rottentomatoes_key}
    FandangoSample %>%
      separate_rows(all_rt_vals, sep = "/", convert = TRUE) %>%
      mutate(rt_key = case_when(
        str_detect(all_rt_vals, "%") ~ "Raw user score (%)",
        str_detect(all_rt_vals, "out of") ~ "Normalized user score (out of 5)",
      ))
    ```
    
2. Next we need to add a zero to the front of the percentages in `all_rt_vals`

    ```{r}
    FandangoSample %>%
      separate_rows(all_rt_vals, sep = "/", convert = TRUE) %>%
      mutate(rt_key = case_when(
        str_detect(all_rt_vals, "%") ~ "Raw user score (%)",
        str_detect(all_rt_vals, "out of") ~ "Normalized user score (out of 5)",
      ))  %>%
      mutate(all_rt_vals = case_when(
        str_detect(all_rt_vals, "%") ~ paste0("0.", all_rt_vals),
        TRUE ~ all_rt_vals
      )) 
    ```

3. Finally, we need to remove the `%` and ` out of 5` text from the numbers in `all_rt_vals`  

    ```{r}
    FandangoSample %>%
      separate_rows(all_rt_vals, sep = "/", convert = TRUE) %>%
      mutate(rt_key = case_when(
        str_detect(all_rt_vals, "%") ~ "Raw user score (%)",
        str_detect(all_rt_vals, "out of") ~ "Normalized user score (out of 5)",
      ))  %>%
      mutate(all_rt_vals = case_when(
        str_detect(all_rt_vals, "%") ~ paste0("0.", all_rt_vals),
        TRUE ~ all_rt_vals
      )) %>%
      mutate(
        all_rt_vals = str_remove_all(all_rt_vals, "%| out of 5"),
        all_rt_vals = as.double(all_rt_vals)
      )
    ```


### solution

This isn't as clear as it could be, so we will use `mutate()`, `case_when()`, and `str_detect()` to create an index variable for the `rottentomatoes_scores`, which we will call `rottentomatoes_score`. We'll also remove the `%` and `out of 5` text from `rottentomatoes_scores`, and rename this to `rottentomatoes_value`. 

```{r FandangoSampleTidy}
# FandangoSampleTidy <- FandangoSample %>% 
#   separate_rows(rottentomatoes_scores, sep = "/", convert = TRUE) %>% 
#   mutate(rottentomatoes_score = case_when(
#     str_detect(rottentomatoes_scores, "%") ~ "raw user score (%)", 
#     str_detect(rottentomatoes_scores, "out of 5") ~ "normalized user score (out of 5)", 
#     TRUE ~ NA_character_),
#     rottentomatoes_value = str_remove_all(string = rottentomatoes_scores, "%|out of 5"), 
#     rottentomatoes_value = as.numeric(rottentomatoes_value)
#   ) %>% 
#   select(-rottentomatoes_scores)
# FandangoSampleTidy
```

Notice this new dataset, `FandangoSampleTidy`, has twice the number of rows as the original `FandangoSample`. 

```{r review-FandangoSample}
FandangoSample
```

***

## `unite()` 

Just like `separate`/`separate_rows` allows us to split up columns, `unite()` lets us stick them back together! Take a look at `DailyShowSample`.

```{r review-DailyShowSample}
DailyShowSample
```

We can see the guests have had their names in separate columns (`first_name` and `last_name`).


### exercise 

Unite `first_name` and `last_name` into `guest_name` (don't remove the previous columns with `remove = FALSE`).

```{r unite, eval=FALSE}
DailyShowSample %>% 
    unite(col = "_______", first_name:last_name, sep = " ", remove = _____)
```

### solution

Unite `first_name` and `last_name` into `guest_name` (don't remove the previous columns with `remove = FALSE`).

```{r unite-solution-3}
DailyShowSample %>% 
    unite(col = "guest_name", first_name:last_name, sep = " ", remove = FALSE)
```

***

# Joins

Joins give us the ability to combine multiple datasets on a common column. We're going to be using the [`starwarsdb` package](https://github.com/gadenbuie/starwarsdb), which contains data from the [Star Wars API](https://swapi.dev/). 

We'll load the data below: 

```{r starwarsdb-package, message=FALSE}
library(starwarsdb)
library(dm)
```

## `starwarsdb`

The code below creates and displays the data model for the tables in this package 

```{r StarWarsDataModel, message=FALSE, warning=FALSE}
StarWarsDataModel <- dm_draw(dm = starwars_dm(), 
                             graph_name = "StarWarsDataModel")
StarWarsDataModel
```



### exercise

Load the `starwarsdb::films` dataset, removing the `opening_crawl` column, and filter to only episodes 4-6. Store these data in `StarWarsFilms`

```{r films-ex, eval=FALSE}
StarWarsFilms <- starwarsdb::films %>% 
                    select(-____________) %>% 
                    filter(episode_id >= ___ & episode_id <= ___)
StarWarsFilms
```

### solution 

```{r films-sol}
StarWarsFilms <- starwarsdb::films %>% 
                    select(-c(opening_crawl, director, producer)) %>% 
                    filter(episode_id >= 4 & episode_id <= 6)
StarWarsFilms
```


## `left_join`

A `left_join` keeps all of `x`, and joins it to all matching rows from dataset `y`

### exercise

Left-join `StarWarsFilms` to `starwarsdb::films_vehicles` on `"title"`, then `select()` the `vehicle` column, then `everything()` else. 

Assign to `StarWarsFilmVeh`

```{r StarWarsFilmsPeople-ex, eval=FALSE}
left_join(x = _____________, 
          y = starwarsdb::films_vehicles, 
          by = ______) %>% 
    select(_____________, 
           everything()) -> StarWarsFilmVeh
StarWarsFilmVeh
```

### solution



```{r StarWarsFilmsPeople}
left_join(x = StarWarsFilms, 
          y = starwarsdb::films_vehicles, 
          by = "title") %>% 
  select(vehicle, 
         everything()) -> StarWarsFilmVeh
StarWarsFilmVeh
```

## `inner_join`

The `inner_join()` joins dataset `x` and `y`, and keeps only matching rows from both.

### exercise 

Use an `inner_join` to join `StarWarsFilmVeh` to `starwarsdb::pilots` on `"vehicle"` and assign it to `StarWarsFilmVehPil`.

```{r StarWarsFilmVenPlt-ex, eval=FALSE}
inner_join(x = StarWarsFilmVeh, 
           y = _________, 
           by = _________) -> _____________
StarWarsFilmVehPil
```

### solution



```{r StarWarsFilmVehPil-sol}
inner_join(x = StarWarsFilmVeh, 
           y = starwarsdb::pilots, 
           by = "vehicle") -> StarWarsFilmVehPil
StarWarsFilmVehPil
```

## `right_join`

The `right_join()` includes all the rows in dataset `y`, and joins it the matching rows in dataset `x`.

### exercise

Use a `right_join()` to join `StarWarsFilmVehPlt` to `starwarsdb::films_planets` on `"title"`, keeping all the rows in `starwarsdb::films_planets`. Use `select()` to rename `planet` to `film_planet` and assign this to `StarWarsFilmVehPltPlnt` 

```{r right_join_ex, eval=FALSE}
right_join(x = __________________, 
             y = __________________, 
             by = "title") %>% 
  select(vehicle:release_date,
         film_planet = _______,
         pilot) -> StarWarsFilmVehPltPlnt
```

### solution



```{r right_join-sol}
right_join(x = StarWarsFilmVehPil, 
           y = starwarsdb::films_planets, 
           by = "title") %>% 
  select(vehicle:release_date,
         film_planet = planet, 
         pilot) -> StarWarsFilmVehPltPlnt
StarWarsFilmVehPltPlnt
```

## `anti_join`

The `anti_join()` keeps all rows in dataset `x` that **do not** have a match in dataset `y`. Note the last join created empty values for `vehicle`, `episode_id`, `release_date`, and `pilot`. 

```{r filter-is.na}
StarWarsFilmVehPltPlnt %>% 
  filter(is.na(episode_id))
```

### exercise 

Use the `anti_join()` to join `StarWarsFilmVehPltPlnt` to `StarWarsFilms` and create a dataset with only `title` and `film_planet` (*these should only contain the `title`s not in `StarWarsFilms`*).

```{r anti_join-ex, eval=FALSE}
anti_join(x = StarWarsFilmVehPltPlnt, 
            y = ____________, 
            by = c("title", "episode_id", "release_date")) %>% 
  select(________, ________)
```

### solution 

```{r anti_join-sol}
anti_join(x = StarWarsFilmVehPltPlnt, 
            y = StarWarsFilms, 
            by = c("title", "episode_id", "release_date")) %>% 
  select(title, film_planet)
```
